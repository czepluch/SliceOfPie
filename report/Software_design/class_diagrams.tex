Before we started coding we made a draft of the class diagrams. Throughout the following sprints we kept maintaining and updating the class diagram
draft to make sure that the code and class diagram were in agreement. The final class diagram was refined in the last sprint.

The class diagram is the main building block of object oriented modeling. It is used both for general conceptual modeling of the systematics 
of an application, and for translating models into code or vice versa. The diagram
shows class interfaces as well as the relationship between those classes.

Maintaining class diagrams has been a great help throughout the programming of this application, as they provide a constant and updated reference
for what should be done.

We have shown the most critical and important classes with their most important attributes and public methods (see Appendix \ref{sec:class-diagrams-appendix}). This decision can be largely attributed
to our design process, in which we designed and documented these interfaces, making sure the different parts of our code fitted together.
None of the two GUIs (MvcWebApp and SliceOfPieClient) are shown in the class diagram, but are in two separate class diagrams, as they have been separated
thoroughly through our design. This is shown with the rake symbol on the two classes in the main class diagram.

As the class diagram shows, we have made a single controller that is responsible for all the method calls between the views and back end models. We
have an abstract IFileModel class, from which both the WebFileModel and LocalFileModel inherit from. These classes represent different ways of handling
data, respectively saving directly in central storage or saving to the local file system. Left to the abstract IFileModel class, we have
made a simplification of the folders and documents hierarchy, also discussed in Section \ref{sec:logicalview}.

Furthermore we have a UserModel that takes care of the way users interact with the FileModels and user registration. All that is needed
to register a user is an email address and a password. If a user tries to sign in, but does not exist in the database, the user is created.

\subsubsection{The MvcWebApp GUI}

The class diagram for the MvcWebApp (represented by a rake in the main diagram; Appendix \ref{sec:class-diagrams-appendix}) shows only the controller
classes of the project, since they are the most crucial classes for understanding how the Web UI works. Additionally, the model used in the project
are the basic classes defined in SliceOfPie.dl, which ensures consistency between the Web client and the local client. The Web UI uses the ASP.NET MVC3 Framework. We decided to use MVC since we thought it to be suitable
for our needs, building simple pages quickly.

The \emph{views} of the MVC3 structure have been omitted. This is done because they do not have any important or interesting functionality except for
defining the HTML for each web page. The controller methods with a [GET] attribute, get a desired view and those with a [POST] attribute are executed on
POST HTTP requests.

For each method in a controller there is a corresponding view that is rendered when the method is called. Two methods with the same 
name in the controller use a single view.

The ASP.NET MVC3 Framework is based on the Model-View-Controller pattern (as it is aptly named after). It ensures a separation between data and how
it is represented visually. It makes a web application easy to maintain and expand. The views generated by the framework follow the HTML5 standard.

\subsubsection{The SliceOfPieClient GUI}

The local client can be seen as the view in a larger-scale MVC pattern applied to the entire application.

As well as with the MvcWebApp GUI class diagram we have chosen only to show the most crucial classes and methods in the SliceOfPieClient diagram (see Appendix \ref{sec:class-diagrams-appendix}).

Although the course curriculum only covers Windows Forms, we have decided to use Windows Presentation Foundation for the GUI in the local client. We found it relevant to learn and apply this technology as it seems fitting in a partial C\# course, since WPF is less restricted and in general more powerful than Windows Forms (see Programming C\# 4.0  \cite[p.795-796]{Griffiths2010}) \\
Although WPF provides some nice drag-and-drop features in Visual Studio, we have chosen to write everything by hand. This approach gives us more control of what is going on behind the scenes.

The Design Class Diagram for the local client shows how the local UI (and behind-the-scenes logic) is split into several classes. Most of the classes are implemented as WPF User Controls (with custom highly cohesive behavior such as certain mouse events), which means that they can be used across several UI elements just like the build-in WPF Control elements. One example setup of these pluggable components is illustrated graphically in Appendix  \ref{sec:local-gui-reuse}.

All of the custom User Controls are used from and mediated by our MainWindow class, which acts as a coordinator of events between them. As an example of coordination, the MainWindow expands the hierachy in the ItemExplorer, when ever a doubleclick event is fired from the ContainerContentView. Assigning the logical responsibilites of changing ui state to the controlling ui element (MainWindow) is in line with the GRASP principles explained in section \ref{sec:GRASP}. Any business logic in the local client is handled by the controller in the SliceOfPie.dll (the reasoning behind this is elaborated in the GRASP section).

The local client also contains various helper classes for generating images and icons.
